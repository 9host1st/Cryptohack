

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_400 = Integer(400); _sage_const_100 = Integer(100); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_600 = Integer(600); _sage_const_8 = Integer(8); _sage_const_10000 = Integer(10000); _sage_const_1000 = Integer(1000)
import random
from socket import *

tmp = []
all_list = []
tmp_list = []
def miller_rabin(n, b):
    """
    Miller Rabin test testing over all
    prime basis < b
    """
    basis = generate_basis(b)
    if n == _sage_const_2  or n == _sage_const_3 :
        return True

    if n % _sage_const_2  == _sage_const_0 :
        return False

    r, s = _sage_const_0 , n - _sage_const_1 
    while s % _sage_const_2  == _sage_const_0 :
        r += _sage_const_1 
        s //= _sage_const_2 
    for b in basis:
        x = pow(b, s, n)
        if x == _sage_const_1  or x == n - _sage_const_1 :
            continue
        for _ in range(r - _sage_const_1 ):
            x = pow(x, _sage_const_2 , n)
            if x == n - _sage_const_1 :
                break
        else:
            return False
    return True

def generate_basis(n):

    res = [_sage_const_2 ]
    while(_sage_const_1 ):
        tmp = next_prime(int(res[-_sage_const_1 ]))

        if tmp > n:
            return res
        res.append(int(tmp))

def crt(a, p):
    M = _sage_const_1 
    for i in range(len(p)):
        M *= p[i]
    ans = _sage_const_0 
    for i in range(len(p)):
        ans += a[i] * (M // p[i]) * inverse_mod(M//p[i], p[i]);
    return ans % M

primes = generate_basis(_sage_const_400 )
prime_list = generate_basis(primes[-_sage_const_1 ] * _sage_const_100 )
S = []

print(primes)
print(prime_list)
for i in range(len(primes)):
    tmp = []
    for pr in prime_list:
        if pr <= primes[i]:
            continue
        res = kronecker(primes[i], pr)
        if res != -_sage_const_1 :
            continue
        res2 = pr % (_sage_const_4 *primes[i])
        try:
            tmp.index(res2)
        except:
            tmp.append(res2)
    tmp.sort()
    S.append(tmp)

flag = _sage_const_0 
for k1 in range(_sage_const_9 , _sage_const_600 , _sage_const_2 ):
    for k2 in range(k1 + _sage_const_2 , _sage_const_600 , _sage_const_2 ):
        error_flag = _sage_const_0 
        if k1 in primes:
            break
        if k2 in primes:
            break
        print(k1, k2)
        k_list = [k1, k2]
        ans_list = []
        for i in range(len(primes)):
            tmp_list = [[] for _ in range(len(k_list))]
            for j in range(len(S[i])):
                for k in range(len(tmp_list)):
                    r = inverse_mod(k_list[k], _sage_const_4  * primes[i]) * (S[i][j]+k_list[k] - _sage_const_1 )
                    r = r % (_sage_const_4  * primes[i])
                    tmp_list[k].append(r)
            ans = list(set(tmp_list[_sage_const_0 ]).intersection(tmp_list[_sage_const_1 ]))
            for j in range(_sage_const_2 , len(k_list)):
                ans = list(set(ans).intersection(tmp_list[j]))
            ans = list(set(ans).intersection(S[i]))
            ans.sort()
            if(len(ans) == _sage_const_0 ):
                print("error!")
                error_flag = _sage_const_1 
            ans_list.append(ans)
        if error_flag:
            continue
        print("ans_list : ")
        print(ans_list)
        print(k_list)
        a1 = inverse_mod(-_sage_const_1  * k_list[_sage_const_0 ], k_list[_sage_const_1 ])
        a2 = inverse_mod(-_sage_const_1  * k_list[_sage_const_1 ], k_list[_sage_const_0 ])
        p_set = [k_list[_sage_const_0 ], k_list[_sage_const_1 ], _sage_const_8 ]
        a_set = [a2, a1, ans_list[_sage_const_0 ][_sage_const_0 ]]
        all_list = []
        for i in range(_sage_const_1 , len(primes)):
            p_set.append(primes[i])
        c = ans_list[_sage_const_0 ][_sage_const_0 ] % _sage_const_4 
        for i in range(_sage_const_1 , len(ans_list)):
            for j in range(len(ans_list[i])):
                if ans_list[i][j] % _sage_const_4  == c:
                    a_set.append(ans_list[i][j] % primes[i])
                    break
        if len(a_set) != len(p_set):
            print("ERROR")
            error_flag = _sage_const_1 
        if error_flag:
            continue

        print(p_set)
        print(a_set)
        c_res = crt(a_set, p_set)
        n = _sage_const_1 
        for j in range(len(p_set)):
            n *= p_set[j]
        print(n)
        print(c_res, n)
        p1 = c_res + n
        print(p1.bit_length())

        for i in range(_sage_const_10000 ):
            if i % _sage_const_1000  == _sage_const_0 :
                print(i)
            p2 = k_list[_sage_const_0 ] * (p1-_sage_const_1 )+_sage_const_1 
            p3 = k_list[_sage_const_1 ] * (p1-_sage_const_1 )+_sage_const_1 
        # print(p1, p2, p3)
        # and isPrime(p2) and isPrime(p3):
            if isPrime(p1):
                if isPrime(p2):
                    if isPrime(p3):
                        print("hooray")
                        flag = _sage_const_1 
                        break
            p1 += n

        if flag:
            print(p1, p2, p3)
            answer = p1 * p2 * p3
            print(miller_rabin(answer, base))
            print(answer.bit_length())
            print(answer)
            break
        print("Hmm")

    if flag:
        break
'''
def generatePrimeList(b): # Generate prime list!
    P = Primes()
    s = P.first(); a = []
    while(s <= b):
        a.append(s)
        s = P.next(s)
    return a

a = generatePrimeList(64)
S = []

for x in a: # Table 3 
    b = 4 * x
    p = []
    for k in range(b):
        if kronecker(x, k) == -1:
            p.append(k)
    s = []
    for k in p:
        if gcd(k, b) == 1:
            s.append(k)
    S.append(s)

h = 3
k_list = [1]
for i in range(1, 3): #  select ki
    for j in range(2, 237):
        isP = False
        for k in a:
            if gcd(j, k) != 1:
                isP = True
                break
        if isP == False and not j in k_list:
            k_list.append(j)
            break
        
subset = []

for i, l in enumerate(S): # Table 4
    b = 4 * a[i]
    l1 = set([])
    for j,k in enumerate(k_list):
        l2 = set([])
        k_inverse = inverse_mod(k, b)
        for s in l:
            l2.add(k_inverse * (s + k - 1) % b)
        if(j == 0):
            l1 = l2
        l1 = l1 & l2
    subset.append(sorted(l1))

a.append(8)
for i in range(1, len(k_list)):
    a.append(k_list[i])

table_list = [] 

for k in subset:
    table_list.append(k[random.randrange(0,len(k))])
table_list.append(3)

table_list.append(inverse_mod(-k_list[2], k_list[1]))
table_list.append(inverse_mod(-k_list[1], k_list[2]))
assert len(a) == len(table_list)

r = 1
for x in a:
    r *= x
print(r)
p = lcm(a) * 2
t = crt(table_list, a)

print(p)
print(t)

k = (2^200 - t) // p

while True:
    p1 = p * k + t
    k += 1
    if is_prime(p1) and (int(p1).bit_length() >= 200):
        p2 = k_list[1] * (p1 - 1) + 1
        p3 = k_list[2] * (p1 - 1) + 1
        if is_prime(p2) and is_prime(p3):
            N = p1 * p2 * p3
            sock = socket(AF_INET, SOCK_STREAM)
            sock.connect(('socket.cryptohack.org', 13385))
            print(sock.recv(1000))
            payload = b'{"base":25, "prime":' + str(N).encode() + b"}"
            print(payload)
            sock.send(payload)
            data = sock.recv(1000)
            print(data)
            if b"flag" in data:
                print(data)
                exit()
            else:
                sock.close()
'''

